#!/usr/bin/env bash

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"
COMPOSE_FILE="${PROJECT_ROOT}/docker/dev/docker-compose.yml"
APP_SERVICE="php"
APP_ROOT="${PROJECT_ROOT}/src"
XDEBUG_INI="${PROJECT_ROOT}/docker/dev/php/conf.d/xdebug.ini"
XDEBUG_DEFAULT_HOST="${XDEBUG_CLIENT_HOST:-host.docker.internal}"
XDEBUG_DEFAULT_PORT="${XDEBUG_CLIENT_PORT:-9003}"
COMMANDS=(
    up down restart status shell spark composer php logs
    init doctor test lint audit build xdebug fresh migrate tinker backup setup
)

SETUP_MARK_START="# >>> c4ignite setup >>>"
SETUP_MARK_END="# <<< c4ignite setup <<<"
C4IGNITE_BIN="${PROJECT_ROOT}/scripts/c4ignite"
COMPLETIONS_DIR="${PROJECT_ROOT}/scripts/completions"
ENV_TEMPLATES_DIR="${PROJECT_ROOT}/templates/env"
BACKUP_DIR="${PROJECT_ROOT}/backups"
APPSTARTER_CACHE_DIR="${BACKUP_DIR}/cache"
PYTHON_HELPER="${SCRIPT_DIR}/python/c4ignite_tools.py"

COMPOSE_CMD=""
COMPOSE_ARGS=()
COMPOSE_DISPLAY=""

die() {
    printf 'Error: %s\n' "$*" >&2
    exit 1
}

ensure_compose() {
    if command -v docker >/dev/null 2>&1 && docker compose version >/dev/null 2>&1; then
        COMPOSE_CMD="docker"
        COMPOSE_ARGS=(compose)
        COMPOSE_DISPLAY="docker compose"
    elif command -v docker-compose >/dev/null 2>&1; then
        COMPOSE_CMD="docker-compose"
        COMPOSE_ARGS=()
        COMPOSE_DISPLAY="docker-compose"
    else
        die "docker compose is required but not installed"
    fi
}

ensure_compose

compose() {
    "${COMPOSE_CMD}" "${COMPOSE_ARGS[@]}" -f "${COMPOSE_FILE}" "$@"
}

compose_exec() {
    local service="$1"
    shift
    if [[ "${service}" == "${APP_SERVICE}" ]]; then
        compose exec --workdir /var/www/html "${service}" "$@"
    else
        compose exec "${service}" "$@"
    fi
}

python_exec() {
    local script="${1}"
    shift

    if [[ "${C4IGNITE_ALLOW_HOST_PYTHON:-0}" -eq 1 ]] && command -v python3 >/dev/null 2>&1; then
        python3 "$script" "$@"
        return
    fi

    local container_script="${script}"
    if [[ "${container_script}" == "${PROJECT_ROOT}" ]]; then
        container_script="/workspace"
    elif [[ "${container_script}" == ${PROJECT_ROOT}/* ]]; then
        container_script="/workspace/${container_script#${PROJECT_ROOT}/}"
    fi

    local -a args=()
    for arg in "$@"; do
        if [[ "${arg}" == "${PROJECT_ROOT}" ]]; then
            args+=("/workspace")
        elif [[ "${arg}" == ${PROJECT_ROOT}/* ]]; then
            args+=("/workspace/${arg#${PROJECT_ROOT}/}")
        else
            args+=("${arg}")
        fi
    done

    compose run --rm --no-deps -T -i python python "${container_script}" "${args[@]}"
}

download_tarball() {
    local url="$1"
    local destination="$2"
    local tmpfile="${destination}.partial"

    mkdir -p "$(dirname "${destination}")"
    if ! curl -fsSL "${url}" -o "${tmpfile}"; then
        rm -f "${tmpfile}"
        die "Failed to download ${url}"
    fi

    mv "${tmpfile}" "${destination}"
}

prompt_yes_no() {
    local prompt="$1"
    local default="${2:-y}"
    local suffix="[Y/n]"
    local answer

    if [[ "${default}" =~ ^[Nn]$ ]]; then
        suffix="[y/N]"
    fi

    if [[ ! -t 0 ]]; then
        [[ "${default}" =~ ^[Yy]$ ]]
        return
    fi

    while true; do
        read -r -p "${prompt} ${suffix} " answer || answer=""
        answer="${answer:-${default}}"
        case "${answer}" in
            [Yy]*) return 0 ;;
            [Nn]*) return 1 ;;
            *) printf 'Masukin y atau n ya.\n' ;;
        esac
    done
}

remove_setup_block() {
    local file="$1"
    [[ -f "${file}" ]] || return 0
    python_exec "${PYTHON_HELPER}" remove-setup-block "$file" "$SETUP_MARK_START" "$SETUP_MARK_END"
}

write_setup_snippet() {
    local file="$1"
    local shell="$2"
    local alias_name="$3"
    local alias_line
    alias_line=$(printf "alias %s=%q" "${alias_name}" "${C4IGNITE_BIN}")

    if [[ "${shell}" == "bash" ]]; then
        local completion="${COMPLETIONS_DIR}/c4ignite.bash"
        cat >> "${file}" <<EOF

${SETUP_MARK_START}
${alias_line}
if [ -f "${completion}" ]; then
  source "${completion}"
fi
${SETUP_MARK_END}
EOF
    else
        local completion="${COMPLETIONS_DIR}/c4ignite.zsh"
        cat >> "${file}" <<EOF

${SETUP_MARK_START}
${alias_line}
if command -v compinit >/dev/null 2>&1; then
  autoload -U compinit && compinit
fi
if [ -f "${completion}" ]; then
  source "${completion}"
fi
${SETUP_MARK_END}
EOF
    fi
}

ensure_requirements() {
    command -v curl >/dev/null 2>&1 || die "curl is required"
    command -v tar >/dev/null 2>&1 || die "tar is required"
    if curl -H "Accept: application/vnd.github+json" -s -I https://api.github.com/rate_limit | grep -qi '403 rate limit'; then
        die "GitHub API rate limit exceeded. Set GH_TOKEN env var dengan token PAT (minimal read repo) atau coba lagi nanti."
    fi
}

cmd_up() {
    compose up -d --build
}

cmd_down() {
    compose down
}

cmd_restart() {
    compose restart
}

cmd_status() {
    compose ps
}

require_service_running() {
    local service="${1}"
    if [[ -z "$(compose ps -q "${service}" 2>/dev/null)" ]]; then
        die "Service '${service}' is not running. Start the stack first (./scripts/c4ignite up)."
    fi
}

cmd_shell() {
    local target="${1:-${APP_SERVICE}}"
    shift || true
    local default_shell="/bin/bash"
    if [[ "${target}" != "${APP_SERVICE}" ]]; then
        default_shell="/bin/sh"
    fi
    if [[ $# -gt 0 ]]; then
        compose_exec "${target}" "$@"
    else
        compose_exec "${target}" "${default_shell}"
    fi
}

cmd_spark() {
    require_service_running "${APP_SERVICE}"
    compose_exec "${APP_SERVICE}" php spark "$@"
}

cmd_composer() {
    require_service_running "${APP_SERVICE}"
    compose_exec "${APP_SERVICE}" composer "$@"
}

cmd_php() {
    require_service_running "${APP_SERVICE}"
    compose_exec "${APP_SERVICE}" php "$@"
}

cmd_logs() {
    compose logs -f "$@"
}

cmd_fresh() {
    local reinit=0
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --reinit)
                reinit=1
                shift
                ;;
            --help|-h)
                cat <<EOF
Gunakan: c4ignite fresh [--reinit]

- Tanpa opsi: matiin stack + hapus volume compose.
- --reinit: setelah bersih, folder src/ dihapus lalu bootstrap ulang.
EOF
                return 0
                ;;
            *)
                die "opsi fresh tidak dikenali: $1"
                ;;
        esac
    done

    compose down -v --remove-orphans || true

    if [[ ${reinit} -eq 1 ]]; then
        printf "Menghapus isi src/ dan bootstrap ulang...\n"
        rm -rf "${APP_ROOT}" || die "gagal menghapus ${APP_ROOT}"
        "${SCRIPT_DIR}/c4ignite" init || die "init ulang gagal"
    fi
}

cmd_migrate() {
    require_service_running "${APP_SERVICE}"
    compose_exec "${APP_SERVICE}" php spark migrate "$@"
}

cmd_tinker() {
    require_service_running "${APP_SERVICE}"
    compose_exec "${APP_SERVICE}" php spark shell "$@"
}

ensure_lint_script() {
    local composer_file="${APP_ROOT}/composer.json"
    [[ -f "${composer_file}" ]] || die "composer.json tidak ditemukan. Jalankan './scripts/c4ignite init' dulu."

    python_exec "${PYTHON_HELPER}" ensure-lint-script "$composer_file"
}

install_phpcs() {
    require_service_running "${APP_SERVICE}"
    printf 'Menginstall dev dependency squizlabs/php_codesniffer...\n'
    compose_exec "${APP_SERVICE}" composer require --dev squizlabs/php_codesniffer:^3.10 --no-interaction
}

lint_setup() {
    local assume_yes="$1"

    if [[ "${assume_yes}" != "yes" ]]; then
        printf 'Setup lint akan menambahkan script "lint" di composer.json dan menginstall squizlabs/php_codesniffer (dev).\n'
        if ! prompt_yes_no "Lanjut setup lint?" "y"; then
            printf 'Setup lint dibatalkan.\n'
            return 0
        fi
    fi

    ensure_app_root_writable
    local result
    result=$(ensure_lint_script)
    if [[ "${result}" == "ADDED" ]]; then
        printf 'Menambahkan script "lint" ke composer.json\n'
    else
        printf 'Script "lint" sudah tersedia di composer.json\n'
    fi

    local vendor_bin="${APP_ROOT}/vendor/bin/phpcs"
    if [[ ! -f "${vendor_bin}" ]]; then
        install_phpcs
    else
        printf 'PHPCS sudah terpasang di vendor/bin/phpcs\n'
    fi

    printf 'Setup lint selesai. Jalankan "./scripts/c4ignite lint" buat mulai linting.\n'
}

lint_script_exists() {
    local composer_file="${APP_ROOT}/composer.json"
    [[ -f "${composer_file}" ]] || return 1
    python_exec "${PYTHON_HELPER}" lint-script-exists "$composer_file"
}

phpcs_installed() {
    [[ -f "${APP_ROOT}/vendor/bin/phpcs" ]]
}

ensure_backup_dir() {
    mkdir -p "${BACKUP_DIR}" || die "Tidak bisa membuat direktori backup ${BACKUP_DIR}"
}

prompt_passphrase_new() {
    command -v openssl >/dev/null 2>&1 || die "openssl dibutuhkan untuk enkripsi backup"
    local pass1 pass2
    read -s -p "Passphrase baru: " pass1; printf '\n'
    read -s -p "Konfirmasi passphrase: " pass2; printf '\n'
    [[ -n "${pass1}" ]] || die "Passphrase tidak boleh kosong"
    [[ "${pass1}" == "${pass2}" ]] || die "Passphrase tidak cocok"
    BACKUP_PASSPHRASE="${pass1}"
}

prompt_passphrase_existing() {
    command -v openssl >/dev/null 2>&1 || die "openssl dibutuhkan untuk dekripsi backup"
    local pass1
    read -s -p "Passphrase backup: " pass1; printf '\n'
    [[ -n "${pass1}" ]] || die "Passphrase tidak boleh kosong"
    BACKUP_PASSPHRASE="${pass1}"
}

create_backup_metadata() {
    local file="$1"
    local includes_vendor="$2"
    local includes_writable="$3"
    local exclude_env="$4"
    local encrypted="$5"
    local commit=""
    if git -C "${PROJECT_ROOT}" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        commit=$(git -C "${PROJECT_ROOT}" rev-parse HEAD 2>/dev/null || echo '')
    fi
    python_exec "${PYTHON_HELPER}" create-backup-metadata "$file" "$includes_vendor" "$includes_writable" "$exclude_env" "$encrypted"
}

backup_generate_default_name() {
    ensure_backup_dir
    local ts
    ts=$(date +%Y%m%d%H%M%S)
    printf '%s/c4ignite-src-%s.tar.gz' "${BACKUP_DIR}" "${ts}"
}

backup_create() {
    ensure_app_root_writable
    [[ -d "${APP_ROOT}" ]] || die "Folder src/ belum ada. Jalankan './scripts/c4ignite init' dulu."

    local output=""
    local include_vendor=0
    local include_writable=0
    local exclude_env=0
    local encrypt=0
    local assume_yes=0
    local auto_mode=0

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --output)
                [[ $# -ge 2 ]] || die "--output butuh path"
                output="$2"
                shift 2
                ;;
            --include-vendor)
                include_vendor=1
                shift
                ;;
            --include-writable)
                include_writable=1
                shift
                ;;
            --exclude-env)
                exclude_env=1
                shift
                ;;
            --encrypt)
                encrypt=1
                shift
                ;;
            -y|--yes)
                assume_yes=1
                shift
                ;;
            --auto)
                auto_mode=1
                shift
                ;;
            --help|-h)
                cat <<'EOF'
Gunakan: c4ignite backup create [opsi]

Opsional:
  --output FILE          Nama file backup (default: backups/c4ignite-src-<timestamp>.tar.gz)
  --include-vendor       Sertakan folder vendor/ (default: tidak)
  --include-writable     Sertakan folder writable/ (default: tidak)
  --exclude-env          Jangan sertakan file .env
  --encrypt              Enkripsi arsip (AES-256, butuh openssl)
  -y, --yes              Lewati konfirmasi (non-interaktif)
EOF
                return 0
                ;;
            *)
                break
                ;;
        esac
    done

    ensure_backup_dir
    local filename
    filename=$(backup_generate_default_name)
    if [[ -n "${output}" ]]; then
        filename="${output}"
    fi

    if [[ ${encrypt} -eq 1 && "${filename}" != *.enc ]]; then
        filename="${filename}.enc"
    fi

    if [[ ${auto_mode} -ne 1 && ${assume_yes} -ne 1 ]]; then
        printf 'Backup akan disimpan ke %s\n' "${filename}"
        if ! prompt_yes_no "Lanjut membuat backup?" "y"; then
            printf 'Backup dibatalkan.\n'
            return 0
        fi
    fi

    local tar_excludes=()
    if [[ ${include_vendor} -eq 0 ]]; then
        tar_excludes+=('--exclude=vendor')
    fi
    if [[ ${include_writable} -eq 0 ]]; then
        tar_excludes+=('--exclude=writable')
    fi
    if [[ ${exclude_env} -eq 1 ]]; then
        tar_excludes+=('--exclude=.env')
    fi

    local tmpdir
    tmpdir=$(mktemp -d "${PROJECT_ROOT}/.c4ignite-backup.XXXXXX")
    export PROJECT_ROOT
    export C4IGNITE_NOW="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
    export C4IGNITE_GIT_COMMIT="$(git -C "${PROJECT_ROOT}" rev-parse HEAD 2>/dev/null || echo '')"
    create_backup_metadata "${tmpdir}/c4ignite-backup.json" "$([[ ${include_vendor} -eq 1 ]] && echo yes || echo no)" "$([[ ${include_writable} -eq 1 ]] && echo yes || echo no)" "$([[ ${exclude_env} -eq 1 ]] && echo yes || echo no)" "$([[ ${encrypt} -eq 1 ]] && echo yes || echo no)"
    unset C4IGNITE_NOW C4IGNITE_GIT_COMMIT

    local tar_cmd=(tar -czf - "${tar_excludes[@]}" -C "${APP_ROOT}" . -C "${tmpdir}" c4ignite-backup.json)

    if [[ ${encrypt} -eq 1 ]]; then
        [[ ${auto_mode} -eq 1 ]] && die "Mode auto tidak mendukung enkripsi"
        prompt_passphrase_new
        "${tar_cmd[@]}" | openssl enc -aes-256-cbc -pbkdf2 -salt -out "${filename}" -pass pass:"${BACKUP_PASSPHRASE}"
        unset BACKUP_PASSPHRASE
    else
        "${tar_cmd[@]}" > "${filename}"
    fi

    rm -rf "${tmpdir}"
    printf 'Backup tersimpan di %s\n' "${filename}"
}

backup_list() {
    ensure_backup_dir
    local files=("${BACKUP_DIR}"/*)
    if [[ ! -e "${files[0]}" ]]; then
        printf 'Belum ada backup di %s\n' "${BACKUP_DIR}"
        return 0
    fi
    printf 'Daftar backup di %s:\n' "${BACKUP_DIR}"
    ls -1t "${BACKUP_DIR}"
}

extract_metadata_from_archive() {
    local archive="$1"
    local encrypted="$2"
    local passphrase="$3"
    if [[ "${encrypted}" == "yes" ]]; then
        openssl enc -d -aes-256-cbc -pbkdf2 -pass pass:"${passphrase}" -in "${archive}" | tar -xOf - c4ignite-backup.json 2>/dev/null
    else
        tar -xOf "${archive}" c4ignite-backup.json 2>/dev/null
    fi
}

backup_info() {
    local archive="$1"
    if [[ -f "${archive}" ]]; then
        :
    elif [[ -f "${BACKUP_DIR}/${archive}" ]]; then
        archive="${BACKUP_DIR}/${archive}"
    else
        die "File backup tidak ditemukan: ${archive}"
    fi
    local encrypted="no"
    [[ "${archive}" == *.enc ]] && encrypted="yes"

    printf 'File : %s\n' "${archive}"
    printf 'Ukuran: '
    du -h "${archive}" | awk '{print $1}'
    printf 'Encrypted: %s\n' "${encrypted}"

    local metadata=""
    if [[ "${encrypted}" == "yes" ]]; then
        prompt_passphrase_existing
        metadata=$(extract_metadata_from_archive "${archive}" "yes" "${BACKUP_PASSPHRASE}") || true
        unset BACKUP_PASSPHRASE
    else
        metadata=$(extract_metadata_from_archive "${archive}" "no" "") || true
    fi

    if [[ -n "${metadata}" ]]; then
        printf 'Metadata:\n%s\n' "${metadata}"
    else
        printf 'Metadata tidak bisa dibaca (mungkin backup lama).\n'
    fi
}

backup_preview_contents() {
    local archive="$1"
    local encrypted="$2"
    local passphrase="$3"
    printf 'Cuplikan isi backup:\n'
    if [[ "${encrypted}" == "yes" ]]; then
        openssl enc -d -aes-256-cbc -pbkdf2 -pass pass:"${passphrase}" -in "${archive}" | tar -tzf - | head -n 20
    else
        tar -tzf "${archive}" | head -n 20
    fi
}

backup_restore() {
    local archive=""
    local assume_yes=0
    local auto_backup=0
    local interactive=0

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --file)
                [[ $# -ge 2 ]] || die "--file butuh path"
                archive="$2"
                shift 2
                ;;
            --auto-backup)
                auto_backup=1
                shift
                ;;
            -y|--yes)
                assume_yes=1
                shift
                ;;
            --interactive)
                interactive=1
                shift
                ;;
            --help|-h)
                cat <<'EOF'
Gunakan: c4ignite backup restore --file <arsip> [opsi]

Opsional:
  --auto-backup   Otomatis backup src/ sebelum restore.
  -y, --yes       Skip konfirmasi.
  --interactive   Pilih arsip dari daftar (abaikan --file).
EOF
                return 0
                ;;
            *)
                archive="$1"
                shift
                ;;
        esac
    done

    if [[ ${interactive} -eq 1 ]]; then
        if [[ ! -t 0 ]]; then
            archive=$(ls -1t "${BACKUP_DIR}" 2>/dev/null | head -n1)
            [[ -n "${archive}" ]] || die "Belum ada backup di ${BACKUP_DIR}"
            archive="${BACKUP_DIR}/${archive}"
            printf 'Memakai backup terbaru: %s\n' "${archive}"
        else
        ensure_backup_dir
        local backups=("${BACKUP_DIR}"/*)
        if [[ ! -e "${backups[0]}" ]]; then
            die "Belum ada backup di ${BACKUP_DIR}"
        fi
        printf 'Pilih backup yang mau direstore:\n'
        local index=1
        for file in "${backups[@]}"; do
            printf '  %d) %s\n' "${index}" "$(basename "${file}")"
            index=$((index + 1))
        done
        local choice=""
        while true; do
            read -r -p "Nomor pilihan: " choice || choice=""
            if [[ "${choice}" =~ ^[0-9]+$ && ${choice} -ge 1 && ${choice} -lt ${index} ]]; then
                archive="${backups[$((choice-1))]}"
                break
            else
                printf 'Input tidak valid. Coba lagi.\n'
            fi
        done
        fi
    fi

    [[ -n "${archive}" ]] || die "Harus menentukan arsip backup"
    if [[ -f "${archive}" ]]; then
        :
    elif [[ -f "${BACKUP_DIR}/${archive}" ]]; then
        archive="${BACKUP_DIR}/${archive}"
    else
        die "File backup tidak ditemukan: ${archive}"
    fi

    local encrypted="no"
    [[ "${archive}" == *.enc ]] && encrypted="yes"

    local passphrase=""
    if [[ "${encrypted}" == "yes" ]]; then
        prompt_passphrase_existing
        passphrase="${BACKUP_PASSPHRASE}"
    fi

    if [[ ${assume_yes} -ne 1 ]]; then
        if ! prompt_yes_no "Lanjut restore ke ${APP_ROOT}?" "n"; then
            printf 'Restore dibatalkan.\n'
            unset BACKUP_PASSPHRASE
            return 0
        fi
    fi

    printf 'Menyiapkan restore (folder %s akan diganti)...\n' "${APP_ROOT}"

    if [[ ${auto_backup} -eq 1 ]]; then
        printf 'Membuat backup otomatis sebelum restore...\n'
        backup_create --auto >/dev/null
    else
        if [[ ${assume_yes} -ne 1 ]]; then
            if prompt_yes_no "Backup src/ terlebih dahulu?" "y"; then
                backup_create --auto >/dev/null
            fi
        fi
    fi

    rm -rf "${APP_ROOT}"
    mkdir -p "${APP_ROOT}"

    if [[ "${encrypted}" == "yes" ]]; then
        openssl enc -d -aes-256-cbc -pbkdf2 -pass pass:"${passphrase}" -in "${archive}" | tar -xzf - -C "${APP_ROOT}"
        unset BACKUP_PASSPHRASE
    else
        tar -xzf "${archive}" -C "${APP_ROOT}"
    fi

    rm -f "${APP_ROOT}/c4ignite-backup.json"
    printf 'Restore selesai ke %s\n' "${APP_ROOT}"
}


cmd_setup_shell() {
    local shell_opt=""
    local alias_name="c4"
    local uninstall=0
    local assume_yes=0

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --shell)
                [[ $# -ge 2 ]] || die "--shell butuh nama shell (bash/zsh)"
                shell_opt="$2"
                shift 2
                ;;
            --alias)
                [[ $# -ge 2 ]] || die "--alias butuh nama alias"
                alias_name="$2"
                shift 2
                ;;
            --uninstall)
                uninstall=1
                shift
                ;;
            -y|--yes)
                assume_yes=1
                shift
                ;;
            --help|-h)
                cat <<'EOF'
Gunakan: c4ignite setup shell [opsi]

Opsional:
  --shell bash|zsh   Paksa target shell (default deteksi dari $SHELL)
  --alias NAME       Alias yang dipasang (default: c4)
  --uninstall        Hapus konfigurasi yang pernah dipasang
  -y, --yes          Skip konfirmasi
EOF
                return 0
                ;;
            *)
                die "opsi setup shell tidak dikenali: $1"
                ;;
        esac
    done

    local shell="${shell_opt:-${SHELL##*/}}"
    case "${shell}" in
        bash|zsh) ;;
        *)
            if [[ ${assume_yes} -eq 1 ]]; then
                die "Shell tidak dikenali. Gunakan --shell bash|zsh"
            fi
            shell=""
            while [[ -z "${shell}" ]]; do
                read -r -p "Pilih shell (bash/zsh): " shell || shell=""
                case "${shell}" in
                    bash|zsh) ;;
                    *) printf 'Shell tidak valid, coba lagi.\n' ; shell="" ;;
                esac
            done
            ;;
    esac

    local rc_file
    if [[ "${shell}" == "bash" ]]; then
        rc_file="${HOME}/.bashrc"
    else
        rc_file="${HOME}/.zshrc"
    fi

    if [[ ${uninstall} -eq 1 ]]; then
        if [[ -f "${rc_file}" ]]; then
            remove_setup_block "${rc_file}"
            printf 'Snippet c4ignite dibersihkan dari %s (kalau ada).\n' "${rc_file}"
        else
            printf 'File %s tidak ditemukan, tidak ada yang dihapus.\n' "${rc_file}"
        fi
        return 0
    fi

    if [[ ! "${alias_name}" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]]; then
        die "Alias hanya boleh huruf/angka/underscore dan tidak boleh diawali angka"
    fi

    if [[ ${assume_yes} -ne 1 ]]; then
        printf 'Shell target : %s\n' "${shell}"
        printf 'File config  : %s\n' "${rc_file}"
        printf 'Alias        : %s\n' "${alias_name}"
        if ! prompt_yes_no "Lanjut pasang snippet?" "y"; then
            printf 'Instalasi dibatalkan.\n'
            return 0
        fi
    fi

    touch "${rc_file}"
    remove_setup_block "${rc_file}"
    write_setup_snippet "${rc_file}" "${shell}" "${alias_name}"
    printf 'Snippet c4ignite dipasang di %s. Reload shell (source %s) atau buka terminal baru.\n' "${rc_file}" "${rc_file}"
}

list_env_templates() {
    printf 'Template environment tersedia:\n'
    for file in "${ENV_TEMPLATES_DIR}"/*.env; do
        [[ -f "$file" ]] || continue
        printf '  - %s\n' "${file##*/}"
    done
}

copy_env_template() {
    local name="$1"
    local target="${APP_ROOT}/.env"
    local source="${ENV_TEMPLATES_DIR}/${name}.env"
    if [[ ! -f "${source}" ]]; then
        die "Template ${name} tidak ditemukan. Lihat daftar dengan 'c4ignite setup env list'."
    fi

    ensure_app_root_writable
    mkdir -p "${APP_ROOT}"

    local message="Menimpa ${target} dengan template ${name}. Lanjut?"
    if [[ -f "${target}" ]]; then
        if ! prompt_yes_no "${message}" "n"; then
            printf 'Dibatalkan, file lama tetap dipertahankan.\n'
            return 0
        fi
    fi

    cp "${source}" "${target}"
    printf 'Template %s disalin ke %s\n' "${name}" "${target}"
}

cmd_env() {
    local action="${1:-}"
    shift || true
    case "${action}" in
        list)
            list_env_templates
            ;;
        copy)
            local name="$1"
            [[ -n "${name}" ]] || die "Gunakan: c4ignite setup env copy <nama>"
            copy_env_template "${name}"
            ;;
        ""|-h|--help)
            cat <<'EOF'
Gunakan: c4ignite setup env <perintah>

Perintah:
  list             Tampilkan template env yang tersedia.
  copy <nama>      Salin template ke src/.env (nama: dev/staging/prod/docker dst).
EOF
            ;;
        *)
            die "Perintah setup env tidak dikenali: ${action}"
            ;;
    esac
}

cmd_setup() {
    local subcmd="${1:-}"
    shift || true
    case "${subcmd}" in
        shell) cmd_setup_shell "$@" ;;
        env) cmd_env "$@" ;;
        ""|-h|--help)
            cat <<'EOF'
Perintah setup tersedia:
  c4ignite setup shell [opsi]   Pasang/hapus alias & auto-complete.
  c4ignite env copy <nama>       Salin template env ke src/.env (nama: dev/staging/prod/docker).
  c4ignite env list              Lihat daftar template env yang tersedia.
EOF
            ;;
        *)
            die "setup subcommand tidak dikenali: ${subcmd}"
            ;;
    esac
}

cmd_backup() {
    local subcmd="${1:-}"
    shift || true
    case "${subcmd}" in
        create) backup_create "$@" ;;
        list) backup_list "$@" ;;
        restore) backup_restore "$@" ;;
        info) [[ $# -ge 1 ]] || die "Gunakan: c4ignite backup info <file>"; backup_info "$1" ;;
        ""|-h|--help)
            cat <<'EOF'
Perintah backup tersedia:
  c4ignite backup create [opsi]   Buat arsip src/ (opsional enkripsi).
  c4ignite backup list            Tampilkan daftar backup di folder backups/.
  c4ignite backup restore <file>  Restore arsip ke src/ (dengan konfirmasi).
  c4ignite backup info <file>     Lihat metadata sebuah arsip.
EOF
            ;;
        *)
            die "backup subcommand tidak dikenali: ${subcmd}"
            ;;
    esac
}

command_ok() {
    local bin="$1"
    local label="${2:-$1}"
    if command -v "${bin}" >/dev/null 2>&1; then
        printf '[OK] %s\n' "${label}"
        return 0
    else
        printf '[MISSING] %s\n' "${label}"
        return 1
    fi
}

port_in_use() {
    local port="$1"
    if command -v ss >/dev/null 2>&1; then
        ss -ltn "( sport = :${port} )" | tail -n +2 | grep -q .
    elif command -v netstat >/dev/null 2>&1; then
        netstat -tln 2>/dev/null | awk '{print $4}' | grep -q ":${port}$"
    elif command -v lsof >/dev/null 2>&1; then
        lsof -i :"${port}" >/dev/null 2>&1
    else
        return 2
    fi
}

cmd_doctor() {
    local pass=1

    printf 'Checking required commands...\n'
    command_ok docker || pass=0
    if [[ "${COMPOSE_DISPLAY}" == "docker compose" ]]; then
        if docker compose version >/dev/null 2>&1; then
            printf '[OK] docker compose\n'
        else
            printf '[MISSING] docker compose plugin\n'
            pass=0
        fi
    else
        command_ok "${COMPOSE_CMD}" "${COMPOSE_DISPLAY}" || pass=0
    fi
    command_ok curl || pass=0
    command_ok tar || pass=0
    if command -v python3 >/dev/null 2>&1; then
        printf '[OK] python3\n'
    elif docker compose -f "${COMPOSE_FILE}" config --services 2>/dev/null | grep -qx 'python'; then
        printf '[OK] python (via docker compose service)\n'
    else
        printf '[MISSING] python3 (install di host atau aktifkan service python)\n'
        pass=0
    fi

    printf '\nChecking exposed ports...\n'
    local ports=(8000 33060 63790 8025)
    for port in "${ports[@]}"; do
        if port_in_use "${port}"; then
            status=$?
            if [[ ${status} -eq 0 ]]; then
                printf '[IN USE] Port %s\n' "${port}"
                pass=0
            elif [[ ${status} -eq 2 ]]; then
                printf '[WARN] Unable to detect status for port %s (no tool)\n' "${port}"
            fi
        else
            printf '[OK] Port %s\n' "${port}"
        fi
    done

    printf '\nSummary: '
    if [[ ${pass} -eq 1 ]]; then
        printf 'All checks passed.\n'
    else
        printf 'Please resolve the issues above.\n'
        return 1
    fi
}

cmd_test() {
    require_service_running "${APP_SERVICE}"
    compose_exec "${APP_SERVICE}" ./vendor/bin/phpunit "$@"
}

cmd_lint() {
    local setup=0
    local assume_yes=0
    local show_help=0

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --setup)
                setup=1
                shift
                ;;
            -y|--yes)
                assume_yes=1
                shift
                ;;
            --help|-h)
                show_help=1
                shift
                ;;
            *)
                break
                ;;
        esac
    done

    if [[ ${show_help} -eq 1 ]]; then
        cat <<'EOF'
Gunakan: c4ignite lint [opsi]

Opsional:
  --setup        Tambahkan script lint + install PHPCS (dev).
  -y, --yes      Skip konfirmasi saat setup.
EOF
        return 0
    fi

    if [[ ${setup} -eq 1 ]]; then
        local auto="no"
        [[ ${assume_yes} -eq 1 ]] && auto="yes"
        lint_setup "${auto}"
        return 0
    fi

    require_service_running "${APP_SERVICE}"

    local lint_script
    lint_script=$(lint_script_exists)
    if [[ "${lint_script}" != "yes" && ! phpcs_installed ]]; then
        printf 'Lint belum dikonfigurasi. Jalankan "./scripts/c4ignite lint --setup" dulu.\n' >&2
        return 1
    fi

    local lint_cmd="if [ -f composer.json ] && composer run-script --list | grep -q '^ *lint'; then composer run lint; elif [ -x vendor/bin/phpcs ]; then vendor/bin/phpcs app; else echo 'Lint belum dikonfigurasi. Jalankan \\\"./scripts/c4ignite lint --setup\\\".' >&2; exit 1; fi"
    compose_exec "${APP_SERVICE}" bash -lc "${lint_cmd}"
}

cmd_audit() {
    require_service_running "${APP_SERVICE}"
    compose_exec "${APP_SERVICE}" composer audit "$@"
}

cmd_build() {
    local tag="c4ignite-app:latest"
    local push=0
    local build_args=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -t|--tag)
                [[ $# -ge 2 ]] || die "--tag requires a value"
                tag="$2"
                shift 2
                ;;
            --tag=*)
                tag="${1#*=}"
                shift
                ;;
            --push)
                push=1
                shift
                ;;
            --build-arg=*)
                build_args+=("${1}")
                shift
                ;;
            --build-arg)
                [[ $# -ge 2 ]] || die "--build-arg requires KEY=VALUE"
                build_args+=("--build-arg" "$2")
                shift 2
                ;;
            *)
                die "Unknown build option: $1"
                ;;
        esac
    done

    docker build \
        -f "${PROJECT_ROOT}/docker/prod/Dockerfile" \
        -t "${tag}" \
        "${build_args[@]}" \
        "${PROJECT_ROOT}"

    if [[ ${push} -eq 1 ]]; then
        docker push "${tag}"
    fi
}

ensure_app_root_writable() {
    local uid="${HOST_UID:-$(id -u)}"
    local gid="${HOST_GID:-$(id -g)}"

    if [[ -d "${APP_ROOT}" ]]; then
        if [[ -w "${APP_ROOT}" ]]; then
            return 0
        fi
        printf 'Adjusting ownership of %s...\n' "${APP_ROOT}"
    else
        if mkdir -p "${APP_ROOT}" 2>/dev/null; then
            return 0
        fi
        printf 'Creating %s failed, trying to fix permissions...\n' "${APP_ROOT}"
    fi

    if [[ "${C4IGNITE_SKIP_DOCKER_FIX:-0}" -eq 1 ]]; then
        printf 'Skipping Docker-based permission fix due to C4IGNITE_SKIP_DOCKER_FIX.\n'
        return 0
    fi

    if ! docker run --rm -v "${PROJECT_ROOT}:/workspace" -w /workspace alpine sh -c "if [ -d src ]; then chown -R ${uid}:${gid} src; fi"; then
        printf 'Warning: failed to adjust ownership via Docker.\n'
    fi

    mkdir -p "${APP_ROOT}" 2>/dev/null || true

    if [[ ! -d "${APP_ROOT}" || ! -w "${APP_ROOT}" ]]; then
        die "Unable to access ${APP_ROOT}. Please fix permissions manually."
    fi
}

apply_env_defaults() {
    local env_file="${APP_ROOT}/.env"
    local docker_env="${APP_ROOT}/.env.docker"

    if [[ -f "${env_file}" ]]; then
        python_exec "${PYTHON_HELPER}" apply-env-defaults "$env_file"
    fi

    if [[ ! -f "${docker_env}" && -f "${PROJECT_ROOT}/templates/env/.env.docker" ]]; then
        cp "${PROJECT_ROOT}/templates/env/.env.docker" "${docker_env}"
    fi
}

github_api_headers() {
    local headers=(-H "Accept: application/vnd.github+json")
    if [[ -n "${GH_TOKEN:-}" ]]; then
        headers+=(-H "Authorization: Bearer ${GH_TOKEN}" -H "X-GitHub-Api-Version: 2022-11-28")
    fi
    printf '%s\n' "${headers[@]}"
}

fetch_appstarter_release() {
    local version="${1:-latest}"
    local release_json release_tag tarball_url
    local -a headers
    IFS=$'\n' read -r -d '' -a headers < <(github_api_headers && printf '\0')

    if [[ "${version}" == "latest" ]]; then
        release_json="$(curl -fsSL "${headers[@]}" https://api.github.com/repos/codeigniter4/appstarter/releases/latest)"
        [[ -n "${release_json}" ]] || die "unable to retrieve release metadata"
        release_tag="$(python_exec "${PYTHON_HELPER}" parse-release tag <<<"${release_json}")"
        [[ -n "${release_tag}" ]] || die "unable to determine latest release tag"
        tarball_url="$(python_exec "${PYTHON_HELPER}" parse-release tarball <<<"${release_json}")"
        [[ -n "${tarball_url}" ]] || die "unable to determine release tarball"
        printf '%s\n' "${release_tag}|${tarball_url}"
    else
        tarball_url="https://api.github.com/repos/codeigniter4/appstarter/tarball/${version}"
        printf '%s\n' "${version}|${tarball_url}"
    fi
}

copy_path() {
    local source="$1"
    local target="$2"
    if [[ -d "${source}" ]]; then
        mkdir -p "${target}"
        if command -v rsync >/dev/null 2>&1; then
            rsync -a "${source}/" "${target}/"
        else
            tar -C "${source}" -cf - . | tar -C "${target}" -xf -
        fi
    elif [[ -f "${source}" ]]; then
        if [[ -f "${target}" ]]; then
            printf 'Skipping existing %s\n' "${target}"
        else
            cp "${source}" "${target}"
        fi
    fi
}

cmd_init() {
    ensure_requirements

    local version="latest"
    local positional_version=""
    local force_download=0

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --version)
                [[ $# -ge 2 ]] || die "--version requires a value"
                version="$2"
                shift 2
                ;;
            --force-download|--force)
                force_download=1
                shift
                ;;
            --help|-h)
                cat <<'EOF'
Usage: c4ignite init [version] [--force-download]

Options:
  version             Optional tag/branch to download (defaults to latest release)
  --force-download    Ignore cached tarball and download again
EOF
                return 0
                ;;
            -*)
                die "unknown option for init: $1"
                ;;
            *)
                if [[ -n "${positional_version}" ]]; then
                    die "duplicate version argument: $1"
                fi
                positional_version="$1"
                shift
                ;;
        esac
    done

    if [[ -n "${positional_version}" ]]; then
        version="${positional_version}"
    fi

    if [[ -f "${APP_ROOT}/app/Config/App.php" ]]; then
        printf 'CodeIgniter 4 skeleton already present. Nothing to do.\n'
        return 0
    fi

    local release_info release_tag tarball_url
    release_info="$(fetch_appstarter_release "${version}")"
    release_tag="${release_info%%|*}"
    tarball_url="${release_info#*|}"

    mkdir -p "${APPSTARTER_CACHE_DIR}"
    local cache_file="${APPSTARTER_CACHE_DIR}/appstarter-${release_tag}.tar.gz"

    if [[ ${force_download} -eq 1 ]]; then
        rm -f "${cache_file}"
    fi

    if [[ ! -f "${cache_file}" ]]; then
        printf 'Downloading CodeIgniter appstarter %s...\n' "${release_tag}"
        download_tarball "${tarball_url}" "${cache_file}"
    else
        printf 'Using cached CodeIgniter appstarter %s\n' "${release_tag}"
    fi

    local tmpdir
    tmpdir="$(mktemp -d)"
    trap 'if [[ -n "${tmpdir:-}" ]]; then rm -rf "${tmpdir}"; fi' EXIT

    if ! tar -xz -f "${cache_file}" -C "${tmpdir}" --strip-components=1; then
        rm -rf "${tmpdir}"
        trap - EXIT
        die "Failed to extract cached archive ${cache_file}"
    fi

    ensure_app_root_writable

    local paths=(
        app
        public
        writable
        tests
        spark
        composer.json
        composer.lock
        env
        phpunit.xml.dist
        .gitignore
    )

    for item in "${paths[@]}"; do
        if [[ -e "${tmpdir}/${item}" ]]; then
            copy_path "${tmpdir}/${item}" "${APP_ROOT}/${item}"
        fi
    done

    if [[ ! -f "${APP_ROOT}/.env" && -f "${APP_ROOT}/env" ]]; then
        cp "${APP_ROOT}/env" "${APP_ROOT}/.env"
    fi

    apply_env_defaults

    find "${APP_ROOT}/writable" -type d -exec chmod 775 {} \; 2>/dev/null || true
    find "${APP_ROOT}/writable" -type f -exec chmod 664 {} \; 2>/dev/null || true

    rm -rf "${tmpdir}"
    trap - EXIT

    printf '\nInit complete. Run "./scripts/c4ignite composer install" once containers are up.\n'
}

write_xdebug_config() {
    local mode="$1"
    local start="$2"
    mkdir -p "$(dirname "${XDEBUG_INI}")"
    cat > "${XDEBUG_INI}" <<EOF
[xdebug]
xdebug.mode=${mode}
xdebug.start_with_request=${start}
xdebug.discover_client_host=false
xdebug.client_host=${XDEBUG_DEFAULT_HOST}
xdebug.client_port=${XDEBUG_DEFAULT_PORT}
xdebug.log_level=0
EOF
}

current_xdebug_mode() {
    if [[ -f "${XDEBUG_INI}" ]]; then
        grep -E '^xdebug\.mode=' "${XDEBUG_INI}" | head -n1 | cut -d'=' -f2
    fi
}

reload_php_fpm() {
    if [[ -n "$(compose ps -q "${APP_SERVICE}" 2>/dev/null)" ]]; then
        compose_exec "${APP_SERVICE}" sh -c "kill -USR2 1" >/dev/null 2>&1 || compose_exec "${APP_SERVICE}" sh -c "kill -HUP 1" >/dev/null 2>&1 || true
        printf 'PHP-FPM reloaded with new settings.\n'
    else
        printf 'PHP container is not running; changes will apply on next start.\n'
    fi
}

cmd_xdebug() {
    local action="${1:-status}"
    case "${action}" in
        on)
            write_xdebug_config "debug,develop" "yes"
            printf 'Xdebug enabled (mode=debug,develop)\n'
            reload_php_fpm
            ;;
        off)
            write_xdebug_config "off" "no"
            printf 'Xdebug disabled\n'
            reload_php_fpm
            ;;
        status)
            local mode
            mode="$(current_xdebug_mode)"
            if [[ -z "${mode}" ]]; then
                printf 'Xdebug configuration not found at %s\n' "${XDEBUG_INI}"
            else
                printf 'Xdebug mode: %s\n' "${mode}"
            fi
            ;;
        *)
            die "Usage: c4ignite xdebug [on|off|status]"
            ;;
    esac
}

usage() {
    cat <<EOF
Usage: c4ignite <command> [options]

Commands:
  up            Start the development stack
  down          Stop the stack and remove containers
  restart       Restart running services
  status        Show service status
  shell [svc]   Open shell into a service (default: ${APP_SERVICE})
  spark [...]   Run 'php spark ...' inside the app container
  composer [...] Run Composer inside the app container
  php [...]      Run PHP CLI inside the app container
  logs [svc]    Tail logs for the whole stack or a service
  init [tag]    Download CI4 appstarter (default: latest)
  doctor        Run environment diagnostics
  test [...]    Execute PHPUnit via the app container
  lint          Run project linting (composer script or phpcs fallback)
  audit [...]   Run 'composer audit'
  build [opts]  Build production image (use -t/--tag, --push)
  fresh [opts]  Bersihin container/volume (opsi --reinit untuk reset src/)
  migrate [...] Jalankan php spark migrate
  tinker [...]  Masuk ke php spark shell
  backup [...]  Kelola backup src/ (create/list/restore/info)
  setup shell   Wizard pasang alias + auto-complete ke shell
  setup env     Kelola template .env (list/copy)
  xdebug cmd    Manage xdebug (on|off|status)
EOF
}

main() {
    local cmd="${1:-}"
    shift || true

    case "${cmd}" in
        up) cmd_up "$@" ;;
        down) cmd_down "$@" ;;
        restart) cmd_restart "$@" ;;
        status) cmd_status "$@" ;;
        shell) cmd_shell "$@" ;;
        spark) cmd_spark "$@" ;;
        composer) cmd_composer "$@" ;;
        php) cmd_php "$@" ;;
        logs) cmd_logs "$@" ;;
        init) cmd_init "$@" ;;
        doctor) cmd_doctor "$@" ;;
        test) cmd_test "$@" ;;
        lint) cmd_lint "$@" ;;
        audit) cmd_audit "$@" ;;
        build) cmd_build "$@" ;;
        fresh) cmd_fresh "$@" ;;
        migrate) cmd_migrate "$@" ;;
        tinker) cmd_tinker "$@" ;;
        backup) cmd_backup "$@" ;;
        setup) cmd_setup "$@" ;;
        xdebug) cmd_xdebug "$@" ;;
        ""|-h|--help) usage ;;
        *) usage; die "unknown command: ${cmd}" ;;
    esac
}

main "$@"

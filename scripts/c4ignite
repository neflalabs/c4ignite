#!/usr/bin/env bash

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd -P)"
COMPOSE_FILE="${PROJECT_ROOT}/docker/dev/docker-compose.yml"
APP_SERVICE="php"
APP_ROOT="${PROJECT_ROOT}/src"
XDEBUG_INI="${PROJECT_ROOT}/docker/dev/php/conf.d/xdebug.ini"
XDEBUG_DEFAULT_HOST="${XDEBUG_CLIENT_HOST:-host.docker.internal}"
XDEBUG_DEFAULT_PORT="${XDEBUG_CLIENT_PORT:-9003}"
COMMANDS=(
    up down restart status pull shell spark composer php logs
    init doctor test lint audit build xdebug fresh migrate backup setup
)

SETUP_MARK_START="# >>> c4ignite setup >>>"
SETUP_MARK_END="# <<< c4ignite setup <<<"
C4IGNITE_BIN="${PROJECT_ROOT}/scripts/c4ignite"
COMPLETIONS_DIR="${PROJECT_ROOT}/scripts/completions"
ENV_TEMPLATES_DIR="${PROJECT_ROOT}/templates/env"
BACKUP_DIR="${PROJECT_ROOT}/backups"
APPSTARTER_CACHE_DIR="${BACKUP_DIR}/cache"
PYTHON_HELPER="${SCRIPT_DIR}/python/c4ignite_tools.py"

COMPOSE_CMD=""
COMPOSE_ARGS=()
COMPOSE_DISPLAY=""

die() {
    printf 'Error: %s\n' "$*" >&2
    exit 1
}

ensure_in_project_dir() {
    local current_dir
    current_dir="$(pwd -P)"

    if [[ "${current_dir}" != "${PROJECT_ROOT}" && "${current_dir}" != "${PROJECT_ROOT}"/* ]]; then
        die "c4ignite must be run from within a c4ignite project directory (containing scripts/c4ignite)"
    fi
}

ensure_compose() {
    if command -v docker >/dev/null 2>&1 && docker compose version >/dev/null 2>&1; then
        COMPOSE_CMD="docker"
        COMPOSE_ARGS=(compose)
        COMPOSE_DISPLAY="docker compose"
    elif command -v docker-compose >/dev/null 2>&1; then
        COMPOSE_CMD="docker-compose"
        COMPOSE_ARGS=()
        COMPOSE_DISPLAY="docker-compose"
    else
        die "docker compose is required but not installed"
    fi
}

ensure_in_project_dir
ensure_compose

compose() {
    "${COMPOSE_CMD}" "${COMPOSE_ARGS[@]}" -f "${COMPOSE_FILE}" "$@"
}

compose_exec() {
    local service="$1"
    shift
    if [[ "${service}" == "${APP_SERVICE}" ]]; then
        compose run --rm --no-deps -T -w /var/www/html "${service}" "$@"
        return $?
    else
        set +e
        compose exec "${service}" "$@"
        local status=$?
        set -e
        if [[ ${status} -eq 126 || ${status} -eq 127 || ${status} -eq 128 ]]; then
            compose run --rm --no-deps -T "${service}" "$@"
            return $?
        fi
        return ${status}
    fi
}

python_exec() {
    local script="${1}"
    shift

    if [[ "${C4IGNITE_ALLOW_HOST_PYTHON:-0}" -eq 1 ]] && command -v python3 >/dev/null 2>&1; then
        python3 "$script" "$@"
        return
    fi

    local container_script="${script}"
    if [[ "${container_script}" == "${PROJECT_ROOT}" ]]; then
        container_script="/workspace"
    elif [[ "${container_script}" == ${PROJECT_ROOT}/* ]]; then
        container_script="/workspace/${container_script#${PROJECT_ROOT}/}"
    fi

    local -a args=()
    for arg in "$@"; do
        if [[ "${arg}" == "${PROJECT_ROOT}" ]]; then
            args+=("/workspace")
        elif [[ "${arg}" == ${PROJECT_ROOT}/* ]]; then
            args+=("/workspace/${arg#${PROJECT_ROOT}/}")
        else
            args+=("${arg}")
        fi
    done

    compose run --rm --no-deps -T -i python python "${container_script}" "${args[@]}"
}

download_tarball() {
    local url="$1"
    local destination="$2"
    local tmpfile="${destination}.partial"

    mkdir -p "$(dirname "${destination}")"
    if ! curl -fsSL "${url}" -o "${tmpfile}"; then
        rm -f "${tmpfile}"
        die "Failed to download ${url}"
    fi

    mv "${tmpfile}" "${destination}"
}

prompt_yes_no() {
    local prompt="$1"
    local default="${2:-y}"
    local suffix="[Y/n]"
    local answer

    if [[ "${default}" =~ ^[Nn]$ ]]; then
        suffix="[y/N]"
    fi

    if [[ ! -t 0 ]]; then
        [[ "${default}" =~ ^[Yy]$ ]]
        return
    fi

    while true; do
        read -r -p "${prompt} ${suffix} " answer || answer=""
        answer="${answer:-${default}}"
        case "${answer}" in
            [Yy]*) return 0 ;;
            [Nn]*) return 1 ;;
            *) printf 'Please answer with y or n.\n' ;;
        esac
    done
}

remove_setup_block() {
    local file="$1"
    [[ -f "${file}" ]] || return 0
    local tmp
    tmp="$(mktemp)"
    awk -v start="${SETUP_MARK_START}" -v end="${SETUP_MARK_END}" '
        $0 == start {skip=1; next}
        $0 == end {skip=0; next}
        !skip {print}
    ' "${file}" > "${tmp}"
    mv "${tmp}" "${file}"
}

write_setup_snippet() {
    local file="$1"
    local shell="$2"
    local alias_name="$3"

    if [[ "${shell}" == "bash" ]]; then
        local completion="${COMPLETIONS_DIR}/c4ignite.bash"
        cat >> "${file}" <<EOF

${SETUP_MARK_START}
unalias ${alias_name} >/dev/null 2>&1
unset -f ${alias_name} >/dev/null 2>&1
${alias_name}() {
  local search_dir="\$(pwd -P)"
  while true; do
    if [[ -x "\${search_dir}/scripts/c4ignite" ]]; then
      (
        cd "\${search_dir}" || exit 1
        "\${search_dir}/scripts/c4ignite" "\$@"
      )
      return \$?
    fi
    if [[ "\${search_dir}" == "/" ]]; then
      break
    fi
    search_dir="\${search_dir%/*}"
    [[ -z "\${search_dir}" ]] && search_dir="/"
  done
  printf 'Error: ${alias_name} must be run from within a c4ignite project (scripts/c4ignite not found)\n' >&2
  return 1
}
if [ -f "${completion}" ]; then
  source "${completion}"
fi
${SETUP_MARK_END}
EOF
    else
        local completion="${COMPLETIONS_DIR}/c4ignite.zsh"
        cat >> "${file}" <<EOF

${SETUP_MARK_START}
unfunction ${alias_name} >/dev/null 2>&1
unalias ${alias_name} >/dev/null 2>&1
${alias_name}() {
  local search_dir="\$(pwd -P)"
  while true; do
    if [[ -x "\${search_dir}/scripts/c4ignite" ]]; then
      (
        cd "\${search_dir}" || return 1
        "\${search_dir}/scripts/c4ignite" "\$@"
      )
      return \$?
    fi
    if [[ "\${search_dir}" == "/" ]]; then
      break
    fi
    search_dir="\${search_dir%/*}"
    [[ -z "\${search_dir}" ]] && search_dir="/"
  done
  printf 'Error: ${alias_name} must be run from within a c4ignite project (scripts/c4ignite not found)\n' >&2
  return 1
}
if command -v compinit >/dev/null 2>&1; then
  autoload -U compinit && compinit
fi
if [ -f "${completion}" ]; then
  source "${completion}"
fi
${SETUP_MARK_END}
EOF
    fi
}

ensure_requirements() {
    command -v curl >/dev/null 2>&1 || die "curl is required"
    command -v tar >/dev/null 2>&1 || die "tar is required"
    if curl -H "Accept: application/vnd.github+json" -s -I https://api.github.com/rate_limit >/dev/null 2>&1; then
        if curl -H "Accept: application/vnd.github+json" -s -I https://api.github.com/rate_limit | grep -qi '403 rate limit'; then
            die "GitHub API rate limit exceeded. Set GH_TOKEN (PAT with repo read access) or try again later."
        fi
    else
        printf 'Warning: unable to reach api.github.com, continuing with local cache if available.\n' >&2
    fi
}

cmd_up() {
    local build=0
    local pull=0
    local -a passthrough=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --build)
                build=1
                shift
                ;;
            --pull)
                pull=1
                shift
                ;;
            *)
                passthrough+=("$1")
                shift
                ;;
        esac
    done

    if [[ ${pull} -eq 1 ]]; then
        compose pull
    fi

    local -a up_cmd=(compose up -d)
    if [[ ${build} -eq 1 ]]; then
        up_cmd+=(--build)
    fi

    "${up_cmd[@]}" "${passthrough[@]}"
}

cmd_down() {
    compose down
}

cmd_restart() {
    compose restart
}

cmd_status() {
    compose ps
}

cmd_pull() {
    compose pull "$@"
}

require_service_running() {
    local service="${1}"
    if [[ -z "$(compose ps -q "${service}" 2>/dev/null)" ]]; then
        die "Service '${service}' is not running. Start the stack first (./scripts/c4ignite up)."
    fi
}

cmd_shell() {
    if [[ $# -eq 0 ]]; then
        cat <<EOF
Usage: c4ignite shell <service> [command]

Available services:
$(compose config --format json | python_exec "${PYTHON_HELPER}" list-compose-services | sed 's/^/  - /')

Examples:
  c4ignite shell php /bin/bash
  c4ignite shell mysql mysql --version
EOF
        return 0
    fi

    local target="$1"
    shift
    local default_shell="/bin/bash"
    if [[ "${target}" != "${APP_SERVICE}" ]]; then
        default_shell="/bin/sh"
    fi
    if [[ $# -gt 0 ]]; then
        compose_exec "${target}" "$@"
    else
        compose_exec "${target}" "${default_shell}"
    fi
}

cmd_spark() {
    require_service_running "${APP_SERVICE}"
    compose_exec "${APP_SERVICE}" php spark "$@"
}

composer_prepare_cache() {
    compose run --rm --no-deps -T --user root "${APP_SERVICE}" sh -lc 'mkdir -p /tmp/composer/cache && chown -R 1000:1000 /tmp/composer' >/dev/null 2>&1 || true
}

composer_install_noninteractive() {
    composer_prepare_cache
    compose run --rm --no-deps -T -w /var/www/html "${APP_SERVICE}" composer install --no-interaction
}

cmd_composer() {
    require_service_running "${APP_SERVICE}"
    composer_prepare_cache
    compose_exec "${APP_SERVICE}" composer "$@"
}

cmd_php() {
    require_service_running "${APP_SERVICE}"
    compose_exec "${APP_SERVICE}" php "$@"
}

cmd_logs() {
    compose logs -f "$@"
}

cmd_fresh() {
    local reinit=0
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --reinit)
                reinit=1
                shift
                ;;
            --help|-h)
                cat <<EOF
Usage: c4ignite fresh [--reinit]

- Without options: stop the stack and remove compose volumes.
- --reinit: after cleanup, delete src/ and bootstrap again.
EOF
                return 0
                ;;
            *)
                die "unknown option for fresh: $1"
                ;;
        esac
    done

    compose down -v --remove-orphans || true

    if [[ ${reinit} -eq 1 ]]; then
        printf "Removing src/ contents and bootstrapping again...\n"
        rm -rf "${APP_ROOT}" || die "failed to remove ${APP_ROOT}"
        "${SCRIPT_DIR}/c4ignite" init || die "reinitialisation failed"
    fi
}

cmd_migrate() {
    require_service_running "${APP_SERVICE}"
    compose_exec "${APP_SERVICE}" php spark migrate "$@"
}

ensure_lint_script() {
    local composer_file="${APP_ROOT}/composer.json"
    [[ -f "${composer_file}" ]] || die "composer.json not found. Run './scripts/c4ignite init' first."

    python_exec "${PYTHON_HELPER}" ensure-lint-script "$composer_file"
}

install_phpcs() {
    require_service_running "${APP_SERVICE}"
        printf 'Installing dev dependency squizlabs/php_codesniffer...\n'
    compose_exec "${APP_SERVICE}" composer require --dev squizlabs/php_codesniffer:^3.10 --no-interaction
}

lint_setup() {
    local assume_yes="$1"

    if [[ "${assume_yes}" != "yes" ]]; then
        printf 'Lint setup will add a "lint" script to composer.json and install squizlabs/php_codesniffer (dev).\n'
        if ! prompt_yes_no "Proceed with lint setup?" "y"; then
        printf 'Lint setup cancelled.\n'
            return 0
        fi
    fi

    ensure_app_root_writable
    local result
    result=$(ensure_lint_script)
    if [[ "${result}" == "ADDED" ]]; then
        printf 'Added "lint" script to composer.json\n'
    else
        printf '"lint" script already present in composer.json\n'
    fi

    local vendor_bin="${APP_ROOT}/vendor/bin/phpcs"
    if [[ ! -f "${vendor_bin}" ]]; then
        install_phpcs
    else
        printf 'PHPCS already installed at vendor/bin/phpcs\n'
    fi

    printf 'Lint setup complete. Run "./scripts/c4ignite lint" to start linting.\n'
}

lint_script_exists() {
    local composer_file="${APP_ROOT}/composer.json"
    [[ -f "${composer_file}" ]] || return 1
    python_exec "${PYTHON_HELPER}" lint-script-exists "$composer_file"
}

phpcs_installed() {
    [[ -f "${APP_ROOT}/vendor/bin/phpcs" ]]
}

ensure_backup_dir() {
    mkdir -p "${BACKUP_DIR}" || die "Unable to create backup directory ${BACKUP_DIR}"
}

prompt_passphrase_new() {
    command -v openssl >/dev/null 2>&1 || die "openssl is required for encrypted backups"
    local pass1 pass2
    read -s -p "New passphrase: " pass1; printf '\n'
    read -s -p "Confirm passphrase: " pass2; printf '\n'
    [[ -n "${pass1}" ]] || die "Passphrase cannot be empty"
    [[ "${pass1}" == "${pass2}" ]] || die "Passphrases do not match"
    BACKUP_PASSPHRASE="${pass1}"
}

prompt_passphrase_existing() {
    command -v openssl >/dev/null 2>&1 || die "openssl is required for decrypting backups"
    local pass1
    read -s -p "Backup passphrase: " pass1; printf '\n'
    [[ -n "${pass1}" ]] || die "Passphrase cannot be empty"
    BACKUP_PASSPHRASE="${pass1}"
}

create_backup_metadata() {
    local file="$1"
    local includes_vendor="$2"
    local includes_writable="$3"
    local exclude_env="$4"
    local encrypted="$5"
    local commit=""
    if git -C "${PROJECT_ROOT}" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        commit=$(git -C "${PROJECT_ROOT}" rev-parse HEAD 2>/dev/null || echo '')
    fi
    python_exec "${PYTHON_HELPER}" create-backup-metadata "$file" "$includes_vendor" "$includes_writable" "$exclude_env" "$encrypted"
}

backup_generate_default_name() {
    ensure_backup_dir
    local ts
    ts=$(date +%Y%m%d%H%M%S)
    printf '%s/c4ignite-src-%s.tar.gz' "${BACKUP_DIR}" "${ts}"
}

backup_create() {
    ensure_app_root_writable
    [[ -d "${APP_ROOT}" ]] || die "Directory src/ not found. Run './scripts/c4ignite init' first."

    local output=""
    local include_vendor=0
    local include_writable=0
    local exclude_env=0
    local encrypt=0
    local assume_yes=0
    local auto_mode=0

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --output)
                [[ $# -ge 2 ]] || die "--output requires a path"
                output="$2"
                shift 2
                ;;
            --include-vendor)
                include_vendor=1
                shift
                ;;
            --include-writable)
                include_writable=1
                shift
                ;;
            --exclude-env)
                exclude_env=1
                shift
                ;;
            --encrypt)
                encrypt=1
                shift
                ;;
            -y|--yes)
                assume_yes=1
                shift
                ;;
            --auto)
                auto_mode=1
                shift
                ;;
            --help|-h)
                cat <<'EOF'
Usage: c4ignite backup create [options]

Options:
  --output FILE          Backup filename (default: backups/c4ignite-src-<timestamp>.tar.gz)
  --include-vendor       Include vendor/ directory (default: no)
  --include-writable     Include writable/ directory (default: no)
  --exclude-env          Exclude .env file
  --encrypt              Encrypt archive (AES-256, requires openssl)
  -y, --yes              Skip confirmation (non-interactive)
EOF
                return 0
                ;;
            *)
                break
                ;;
        esac
    done

    ensure_backup_dir
    local filename
    filename=$(backup_generate_default_name)
    if [[ -n "${output}" ]]; then
        filename="${output}"
    fi

    if [[ ${encrypt} -eq 1 && "${filename}" != *.enc ]]; then
        filename="${filename}.enc"
    fi

    if [[ ${auto_mode} -ne 1 && ${assume_yes} -ne 1 ]]; then
        printf 'Backup will be saved to %s\n' "${filename}"
        if ! prompt_yes_no "Continue creating backup?" "y"; then
            printf 'Backup cancelled.\n'
            return 0
        fi
    fi

    local tar_excludes=()
    if [[ ${include_vendor} -eq 0 ]]; then
        tar_excludes+=('--exclude=vendor')
    fi
    if [[ ${include_writable} -eq 0 ]]; then
        tar_excludes+=('--exclude=writable')
    fi
    if [[ ${exclude_env} -eq 1 ]]; then
        tar_excludes+=('--exclude=.env')
    fi

    local tmpdir
    tmpdir=$(mktemp -d "${PROJECT_ROOT}/.c4ignite-backup.XXXXXX")
    export PROJECT_ROOT
    export C4IGNITE_NOW="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
    export C4IGNITE_GIT_COMMIT="$(git -C "${PROJECT_ROOT}" rev-parse HEAD 2>/dev/null || echo '')"
    create_backup_metadata "${tmpdir}/c4ignite-backup.json" "$([[ ${include_vendor} -eq 1 ]] && echo yes || echo no)" "$([[ ${include_writable} -eq 1 ]] && echo yes || echo no)" "$([[ ${exclude_env} -eq 1 ]] && echo yes || echo no)" "$([[ ${encrypt} -eq 1 ]] && echo yes || echo no)"
    unset C4IGNITE_NOW C4IGNITE_GIT_COMMIT

    local tar_cmd=(tar -czf - "${tar_excludes[@]}" -C "${APP_ROOT}" . -C "${tmpdir}" c4ignite-backup.json)

    if [[ ${encrypt} -eq 1 ]]; then
        [[ ${auto_mode} -eq 1 ]] && die "Auto mode does not support encryption"
        prompt_passphrase_new
        "${tar_cmd[@]}" | openssl enc -aes-256-cbc -pbkdf2 -salt -out "${filename}" -pass pass:"${BACKUP_PASSPHRASE}"
        unset BACKUP_PASSPHRASE
    else
        "${tar_cmd[@]}" > "${filename}"
    fi

    rm -rf "${tmpdir}"
    printf 'Backup saved to %s\n' "${filename}"
}

backup_list() {
    ensure_backup_dir
    local files=("${BACKUP_DIR}"/*)
    if [[ ! -e "${files[0]}" ]]; then
        printf 'No backups found in %s\n' "${BACKUP_DIR}"
        return 0
    fi
    printf 'Backups in %s:\n' "${BACKUP_DIR}"
    ls -1t "${BACKUP_DIR}"
}

extract_metadata_from_archive() {
    local archive="$1"
    local encrypted="$2"
    local passphrase="$3"
    if [[ "${encrypted}" == "yes" ]]; then
        openssl enc -d -aes-256-cbc -pbkdf2 -pass pass:"${passphrase}" -in "${archive}" 2>/dev/null | tar -xOf - c4ignite-backup.json 2>/dev/null || return 2
    else
        tar -xOf "${archive}" c4ignite-backup.json 2>/dev/null
    fi
}

backup_info() {
    local archive="$1"
    if [[ -f "${archive}" ]]; then
        :
    elif [[ -f "${BACKUP_DIR}/${archive}" ]]; then
        archive="${BACKUP_DIR}/${archive}"
    else
        die "Backup file not found: ${archive}"
    fi
    local encrypted="no"
    [[ "${archive}" == *.enc ]] && encrypted="yes"

    printf 'File : %s\n' "${archive}"
    printf 'Ukuran: '
    du -h "${archive}" | awk '{print $1}'
    printf 'Encrypted: %s\n' "${encrypted}"

    local metadata=""
    local status=0
    if [[ "${encrypted}" == "yes" ]]; then
        prompt_passphrase_existing
        metadata=$(extract_metadata_from_archive "${archive}" "yes" "${BACKUP_PASSPHRASE}") || status=$?
        unset BACKUP_PASSPHRASE
    else
        metadata=$(extract_metadata_from_archive "${archive}" "no" "") || status=$?
    fi

    if [[ ${status} -eq 2 ]]; then
        printf 'Metadata tidak bisa dibaca: passphrase salah atau arsip korup.\n'
    elif [[ -n "${metadata}" ]]; then
        printf 'Metadata:\n%s\n' "${metadata}"
    else
        printf 'Metadata tidak bisa dibaca (mungkin backup lama).\n'
    fi
}

backup_preview_contents() {
    local archive="$1"
    local encrypted="$2"
    local passphrase="$3"
    printf 'Preview of backup contents:\n'
    if [[ "${encrypted}" == "yes" ]]; then
        openssl enc -d -aes-256-cbc -pbkdf2 -pass pass:"${passphrase}" -in "${archive}" | tar -tzf - | head -n 20
    else
        tar -tzf "${archive}" | head -n 20
    fi
}

backup_restore() {
    local archive=""
    local assume_yes=0
    local auto_backup=0
    local interactive=0

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --file)
                [[ $# -ge 2 ]] || die "--file requires a path"
                archive="$2"
                shift 2
                ;;
            --auto-backup)
                auto_backup=1
                shift
                ;;
            -y|--yes)
                assume_yes=1
                shift
                ;;
            --interactive)
                interactive=1
                shift
                ;;
            --help|-h)
                cat <<'EOF'
Usage: c4ignite backup restore --file <archive> [options]

Options:
  --auto-backup   Automatically back up src/ before restoring
  -y, --yes       Skip confirmation
  --interactive   Choose archive from a list (ignores --file)
EOF
                return 0
                ;;
            *)
                archive="$1"
                shift
                ;;
        esac
    done

    if [[ ${interactive} -eq 1 ]]; then
        ensure_backup_dir
        shopt -s nullglob
        local -a candidate_files=(
            "${BACKUP_DIR}"/*.tar.gz
            "${BACKUP_DIR}"/*.tar.gz.enc
        )
        shopt -u nullglob
        if [[ ${#candidate_files[@]} -eq 0 ]]; then
            die "No backups found in ${BACKUP_DIR}"
        fi
        local -a backup_list
        mapfile -t backup_list < <(ls -1t "${candidate_files[@]}")
        if [[ ! -t 0 ]]; then
            archive="${backup_list[0]}"
            [[ -n "${archive}" ]] || die "No backups found in ${BACKUP_DIR}"
            printf 'Using latest backup: %s\n' "$(basename "${archive}")"
        else
            printf 'Select a backup to restore:\n'
            local index=1
            for file in "${backup_list[@]}"; do
                printf '  %d) %s\n' "${index}" "$(basename "${file}")"
                index=$((index + 1))
            done
            local choice=""
            while true; do
                read -r -p "Select number: " choice || choice=""
                if [[ "${choice}" =~ ^[0-9]+$ && ${choice} -ge 1 && ${choice} -lt ${index} ]]; then
                    archive="${backup_list[$((choice-1))]}"
                    break
                else
                    printf 'Invalid input. Try again.\n'
                fi
            done
        fi
    fi

    [[ -n "${archive}" ]] || die "You must specify a backup archive"
    if [[ -f "${archive}" ]]; then
        :
    elif [[ -f "${BACKUP_DIR}/${archive}" ]]; then
        archive="${BACKUP_DIR}/${archive}"
    else
        die "Backup file not found: ${archive}"
    fi

    local encrypted="no"
    [[ "${archive}" == *.enc ]] && encrypted="yes"

    local passphrase=""
    if [[ "${encrypted}" == "yes" ]]; then
        prompt_passphrase_existing
        passphrase="${BACKUP_PASSPHRASE}"
    fi

    if [[ ${assume_yes} -ne 1 ]]; then
        if ! prompt_yes_no "Proceed with restore to ${APP_ROOT}?" "n"; then
            printf 'Restore cancelled.\n'
            unset BACKUP_PASSPHRASE
            return 0
        fi
    fi

    printf 'Preparing restore (directory %s will be replaced)...\n' "${APP_ROOT}"

    if [[ ${auto_backup} -eq 1 ]]; then
        printf 'Creating automatic backup before restore...\n'
        backup_create --auto >/dev/null
    else
        if [[ ${assume_yes} -ne 1 ]]; then
            if prompt_yes_no "Create a backup of src/ first?" "y"; then
                backup_create --auto >/dev/null
            fi
        fi
    fi

    rm -rf "${APP_ROOT}"
    mkdir -p "${APP_ROOT}"

    if [[ "${encrypted}" == "yes" ]]; then
        openssl enc -d -aes-256-cbc -pbkdf2 -pass pass:"${passphrase}" -in "${archive}" | tar -xzf - -C "${APP_ROOT}"
        unset BACKUP_PASSPHRASE
    else
        tar -xzf "${archive}" -C "${APP_ROOT}"
    fi

    rm -f "${APP_ROOT}/c4ignite-backup.json"
    printf 'Restore completed to %s\n' "${APP_ROOT}"
}


cmd_setup_shell() {
    local shell_opt=""
    local alias_name="c4ignite"
    local uninstall=0
    local assume_yes=0

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --shell)
                [[ $# -ge 2 ]] || die "--shell requires a shell name (bash/zsh)"
                shell_opt="$2"
                shift 2
                ;;
            --alias)
                [[ $# -ge 2 ]] || die "--alias requires a name"
                alias_name="$2"
                shift 2
                ;;
            --uninstall)
                uninstall=1
                shift
                ;;
            -y|--yes)
                assume_yes=1
                shift
                ;;
            --help|-h)
                cat <<'EOF'
Usage: c4ignite setup shell [options]

Options:
  --shell bash|zsh   Force target shell (defaults to $SHELL)
  --alias NAME       Alias to install (default: c4ignite)
  --uninstall        Remove previously installed configuration
  -y, --yes          Skip confirmation
EOF
                return 0
                ;;
            *)
                die "unknown option for setup shell: $1"
                ;;
        esac
    done

    local shell="${shell_opt:-${SHELL##*/}}"
    case "${shell}" in
        bash|zsh) ;;
        *)
            if [[ ${assume_yes} -eq 1 ]]; then
                die "Unknown shell. Use --shell bash|zsh"
            fi
            shell=""
            while [[ -z "${shell}" ]]; do
                read -r -p "Select shell (bash/zsh): " shell || shell=""
                case "${shell}" in
                    bash|zsh) ;;
                    *) printf 'Invalid shell, try again.\n' ; shell="" ;;
                esac
            done
            ;;
    esac

    local rc_file
    if [[ "${shell}" == "bash" ]]; then
        rc_file="${HOME}/.bashrc"
    else
        rc_file="${HOME}/.zshrc"
    fi

    if [[ ${uninstall} -eq 1 ]]; then
        if [[ -f "${rc_file}" ]]; then
            remove_setup_block "${rc_file}"
            printf 'Removed c4ignite snippet from %s (if present).\n' "${rc_file}"
        else
            printf 'File %s not found, nothing to remove.\n' "${rc_file}"
        fi
        return 0
    fi

    if [[ ! "${alias_name}" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]]; then
        die "Alias must contain only letters/numbers/underscore and cannot start with a number"
    fi

    if [[ ${assume_yes} -ne 1 ]]; then
        printf 'Shell target : %s\n' "${shell}"
        printf 'Config file  : %s\n' "${rc_file}"
        printf 'Alias        : %s\n' "${alias_name}"
        if ! prompt_yes_no "Proceed with snippet installation?" "y"; then
            printf 'Installation cancelled.\n'
            return 0
        fi
    fi

    touch "${rc_file}"
    remove_setup_block "${rc_file}"
    write_setup_snippet "${rc_file}" "${shell}" "${alias_name}"
    printf 'Added c4ignite snippet to %s. Reload your shell (source %s) or open a new terminal.\n' "${rc_file}" "${rc_file}"
}

list_env_templates() {
    printf 'Available environment templates:\n'
    for file in "${ENV_TEMPLATES_DIR}"/*.env; do
        [[ -f "$file" ]] || continue
        printf '  - %s\n' "${file##*/}"
    done
}

copy_env_template() {
    local name="$1"
    local target="${APP_ROOT}/.env"
    local source="${ENV_TEMPLATES_DIR}/${name}.env"
    if [[ ! -f "${source}" ]]; then
        die "Template ${name} not found. Run 'c4ignite setup env list' to see available templates."
    fi

    ensure_app_root_writable
    mkdir -p "${APP_ROOT}"

    local message="Overwrite ${target} with template ${name}?"
    if [[ -f "${target}" ]]; then
        if ! prompt_yes_no "${message}" "n"; then
            printf 'Cancelled, existing file kept.\n'
            return 0
        fi
    fi

    cp "${source}" "${target}"
    printf 'Template %s copied to %s\n' "${name}" "${target}"
}

cmd_env() {
    local action="${1:-}"
    shift || true
    case "${action}" in
        list)
            list_env_templates
            ;;
        copy)
            local name="$1"
            [[ -n "${name}" ]] || die "Usage: c4ignite setup env copy <name>"
            copy_env_template "${name}"
            ;;
        ""|-h|--help)
            cat <<'EOF'
Usage: c4ignite setup env <command>

Commands:
  list             Show available env templates
  copy <name>      Copy template to src/.env (names: dev/staging/prod/docker etc.)
EOF
            ;;
        *)
            die "Unknown setup env command: ${action}"
            ;;
    esac
}

cmd_setup() {
    local subcmd="${1:-}"
    shift || true
    case "${subcmd}" in
        shell) cmd_setup_shell "$@" ;;
        env) cmd_env "$@" ;;
        ""|-h|--help)
            cat <<'EOF'
Available setup commands:
  c4ignite setup shell [options]   Install/remove alias & auto-completion
  c4ignite env copy <name>         Copy env template to src/.env (dev/staging/prod/docker)
  c4ignite env list                List available env templates
EOF
            ;;
        *)
            die "Unknown setup subcommand: ${subcmd}"
            ;;
    esac
}

cmd_backup() {
    local subcmd="${1:-}"
    shift || true
    case "${subcmd}" in
        create) backup_create "$@" ;;
        list) backup_list "$@" ;;
        restore) backup_restore "$@" ;;
        info) [[ $# -ge 1 ]] || die "Usage: c4ignite backup info <file>"; backup_info "$1" ;;
        ""|-h|--help)
            cat <<'EOF'
Available backup commands:
  c4ignite backup create [options]   Create archive of src/ (optional encryption)
  c4ignite backup list               List backups in the backups/ directory
  c4ignite backup restore <file>     Restore archive to src/ (with confirmation)
  c4ignite backup info <file>        Show archive metadata
EOF
            ;;
        *)
            die "Unknown backup subcommand: ${subcmd}"
            ;;
    esac
}

command_ok() {
    local bin="$1"
    local label="${2:-$1}"
    if command -v "${bin}" >/dev/null 2>&1; then
        printf '[OK] %s\n' "${label}"
        return 0
    else
        printf '[MISSING] %s\n' "${label}"
        return 1
    fi
}

port_in_use() {
    local port="$1"
    if command -v ss >/dev/null 2>&1; then
        ss -ltn "( sport = :${port} )" | tail -n +2 | grep -q .
    elif command -v netstat >/dev/null 2>&1; then
        netstat -tln 2>/dev/null | awk '{print $4}' | grep -q ":${port}$"
    elif command -v lsof >/dev/null 2>&1; then
        lsof -i :"${port}" >/dev/null 2>&1
    else
        return 2
    fi
}

cmd_doctor() {
    local pass=1

    printf 'Checking required commands...\n'
    command_ok docker || pass=0
    if [[ "${COMPOSE_DISPLAY}" == "docker compose" ]]; then
        if docker compose version >/dev/null 2>&1; then
            printf '[OK] docker compose\n'
        else
            printf '[MISSING] docker compose plugin\n'
            pass=0
        fi
    else
        command_ok "${COMPOSE_CMD}" "${COMPOSE_DISPLAY}" || pass=0
    fi
    command_ok curl || pass=0
    command_ok tar || pass=0
    if command -v python3 >/dev/null 2>&1; then
        printf '[OK] python3\n'
    elif docker compose -f "${COMPOSE_FILE}" config --services 2>/dev/null | grep -qx 'python'; then
        printf '[OK] python (via docker compose service)\n'
    else
        printf '[MISSING] python3 (install on host or enable python service)\n'
        pass=0
    fi

    printf '\nChecking exposed ports...\n'
    local ports=(8000 33060 63790 8025)
    for port in "${ports[@]}"; do
        if port_in_use "${port}"; then
            status=$?
            if [[ ${status} -eq 0 ]]; then
                printf '[IN USE] Port %s\n' "${port}"
                pass=0
            elif [[ ${status} -eq 2 ]]; then
                printf '[WARN] Unable to detect status for port %s (no tool)\n' "${port}"
            fi
        else
            printf '[OK] Port %s\n' "${port}"
        fi
    done

    printf '\nSummary: '
    if [[ ${pass} -eq 1 ]]; then
        printf 'All checks passed.\n'
    else
        printf 'Please resolve the issues above.\n'
        return 1
    fi
}

cmd_test() {
    require_service_running "${APP_SERVICE}"
    compose_exec "${APP_SERVICE}" ./vendor/bin/phpunit "$@"
}

cmd_lint() {
    local setup=0
    local assume_yes=0
    local show_help=0

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --setup)
                setup=1
                shift
                ;;
            -y|--yes)
                assume_yes=1
                shift
                ;;
            --help|-h)
                show_help=1
                shift
                ;;
            *)
                break
                ;;
        esac
    done

    if [[ ${show_help} -eq 1 ]]; then
        cat <<'EOF'
Usage: c4ignite lint [options]

Options:
  --setup        Add lint script and install PHPCS (dev)
  -y, --yes      Skip confirmation during setup
EOF
        return 0
    fi

    if [[ ${setup} -eq 1 ]]; then
        local auto="no"
        [[ ${assume_yes} -eq 1 ]] && auto="yes"
        lint_setup "${auto}"
        return 0
    fi

    require_service_running "${APP_SERVICE}"

    local lint_script
    lint_script=$(lint_script_exists)
    if [[ "${lint_script}" != "yes" && ! phpcs_installed ]]; then
        printf 'Lint is not configured. Run "./scripts/c4ignite lint --setup" first.\n' >&2
        return 1
    fi

    local lint_cmd="if [ -f composer.json ] && composer run-script --list | grep -q '^ *lint'; then composer run lint; elif [ -x vendor/bin/phpcs ]; then vendor/bin/phpcs app; else echo 'Lint is not configured. Run \\\"./scripts/c4ignite lint --setup\\\".' >&2; exit 1; fi"
    compose_exec "${APP_SERVICE}" bash -lc "${lint_cmd}"
}

cmd_audit() {
    require_service_running "${APP_SERVICE}"
    compose_exec "${APP_SERVICE}" composer audit "$@"
}

cmd_build() {
    local tag="c4ignite-app:latest"
    local push=0
    local build_args=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -t|--tag)
                [[ $# -ge 2 ]] || die "--tag requires a value"
                tag="$2"
                shift 2
                ;;
            --tag=*)
                tag="${1#*=}"
                shift
                ;;
            --push)
                push=1
                shift
                ;;
            --build-arg=*)
                build_args+=("${1}")
                shift
                ;;
            --build-arg)
                [[ $# -ge 2 ]] || die "--build-arg requires KEY=VALUE"
                build_args+=("--build-arg" "$2")
                shift 2
                ;;
            *)
                die "Unknown build option: $1"
                ;;
        esac
    done

    docker build \
        -f "${PROJECT_ROOT}/docker/prod/Dockerfile" \
        -t "${tag}" \
        "${build_args[@]}" \
        "${PROJECT_ROOT}"

    if [[ ${push} -eq 1 ]]; then
        docker push "${tag}"
    fi
}

ensure_app_root_writable() {
    local uid="${HOST_UID:-$(id -u)}"
    local gid="${HOST_GID:-$(id -g)}"

    if [[ -d "${APP_ROOT}" ]]; then
        if [[ -w "${APP_ROOT}" ]]; then
            return 0
        fi
        printf 'Adjusting ownership of %s...\n' "${APP_ROOT}"
    else
        if mkdir -p "${APP_ROOT}" 2>/dev/null; then
            return 0
        fi
        printf 'Creating %s failed, trying to fix permissions...\n' "${APP_ROOT}"
    fi

    if [[ "${C4IGNITE_SKIP_DOCKER_FIX:-0}" -eq 1 ]]; then
        printf 'Skipping Docker-based permission fix due to C4IGNITE_SKIP_DOCKER_FIX.\n'
        return 0
    fi

    if ! docker run --rm -v "${PROJECT_ROOT}:/workspace" -w /workspace alpine sh -c "if [ -d src ]; then chown -R ${uid}:${gid} src; fi"; then
        printf 'Warning: failed to adjust ownership via Docker.\n'
    fi

    mkdir -p "${APP_ROOT}" 2>/dev/null || true

    if [[ ! -d "${APP_ROOT}" || ! -w "${APP_ROOT}" ]]; then
        die "Unable to access ${APP_ROOT}. Please fix permissions manually."
    fi
}

apply_env_defaults() {
    local env_file="${APP_ROOT}/.env"
    local docker_env="${APP_ROOT}/.env.docker"

    if [[ -f "${env_file}" ]]; then
        python_exec "${PYTHON_HELPER}" apply-env-defaults "$env_file"
    fi

    if [[ ! -f "${docker_env}" && -f "${PROJECT_ROOT}/templates/env/.env.docker" ]]; then
        cp "${PROJECT_ROOT}/templates/env/.env.docker" "${docker_env}"
    fi
}

github_api_headers() {
    local headers=(-H "Accept: application/vnd.github+json")
    if [[ -n "${GH_TOKEN:-}" ]]; then
        headers+=(-H "Authorization: Bearer ${GH_TOKEN}" -H "X-GitHub-Api-Version: 2022-11-28")
    fi
    printf '%s\n' "${headers[@]}"
}

fetch_appstarter_release() {
    local version="${1:-latest}"
    local release_json release_tag tarball_url
    local -a headers
    IFS=$'\n' read -r -d '' -a headers < <(github_api_headers && printf '\0')

    if [[ "${version}" == "latest" ]]; then
        if [[ "${C4IGNITE_FORCE_OFFLINE:-0}" -eq 1 ]]; then
            return 1
        fi
        if ! release_json="$(curl -fsSL "${headers[@]}" https://api.github.com/repos/codeigniter4/appstarter/releases/latest)"; then
            return 1
        fi
        [[ -n "${release_json}" ]] || return 1
        release_tag="$(python_exec "${PYTHON_HELPER}" parse-release tag <<<"${release_json}")"
        [[ -n "${release_tag}" ]] || return 1
        tarball_url="$(python_exec "${PYTHON_HELPER}" parse-release tarball <<<"${release_json}")"
        [[ -n "${tarball_url}" ]] || return 1
        printf '%s\n' "${release_tag}|${tarball_url}"
    else
        tarball_url="https://api.github.com/repos/codeigniter4/appstarter/tarball/${version}"
        printf '%s\n' "${version}|${tarball_url}"
    fi
}

copy_path() {
    local source="$1"
    local target="$2"
    if [[ -d "${source}" ]]; then
        mkdir -p "${target}"
        if command -v rsync >/dev/null 2>&1; then
            rsync -a "${source}/" "${target}/"
        else
            tar -C "${source}" -cf - . | tar -C "${target}" -xf -
        fi
    elif [[ -f "${source}" ]]; then
        if [[ -f "${target}" ]]; then
            printf 'Skipping existing %s\n' "${target}"
        else
            cp "${source}" "${target}"
        fi
    fi
}

latest_cached_appstarter() {
    shopt -s nullglob
    local files=("${APPSTARTER_CACHE_DIR}"/appstarter-*.tar.gz)
    shopt -u nullglob
    if [[ ${#files[@]} -eq 0 ]]; then
        return 1
    fi
    local latest
    latest=$(ls -1t "${APPSTARTER_CACHE_DIR}"/appstarter-*.tar.gz 2>/dev/null | head -n1)
    [[ -n "${latest}" ]] || return 1
    latest="${latest##*/}"
    latest="${latest#appstarter-}"
    latest="${latest%.tar.gz}"
    printf '%s\n' "${latest}"
}

cmd_init() {
    ensure_requirements

    local version="latest"
    local positional_version=""
    local force_download=0
    local skip_install=0

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --version)
                [[ $# -ge 2 ]] || die "--version requires a value"
                version="$2"
                shift 2
                ;;
            --force-download|--force)
                force_download=1
                shift
                ;;
            --no-install)
                skip_install=1
                shift
                ;;
            --help|-h)
                cat <<'EOF'
Usage: c4ignite init [version] [--force-download] [--no-install]

Options:
  version             Optional tag/branch to download (defaults to latest release)
  --force-download    Ignore cached tarball and download again
  --no-install        Skip running composer install after init
EOF
                return 0
                ;;
            -*)
                die "unknown option for init: $1"
                ;;
            *)
                if [[ -n "${positional_version}" ]]; then
                    die "duplicate version argument: $1"
                fi
                positional_version="$1"
                shift
                ;;
        esac
    done

    if [[ -n "${positional_version}" ]]; then
        version="${positional_version}"
    fi

    if [[ -f "${APP_ROOT}/app/Config/App.php" ]]; then
        printf 'CodeIgniter 4 skeleton already present. Nothing to do.\n'
        return 0
    fi

    mkdir -p "${APPSTARTER_CACHE_DIR}"

    local release_info=""
    local release_tag=""
    local tarball_url=""
    local cache_file=""

    if [[ "${version}" == "latest" ]]; then
        if release_info="$(fetch_appstarter_release "${version}")"; then
            release_tag="${release_info%%|*}"
            tarball_url="${release_info#*|}"
        else
            release_tag="$(latest_cached_appstarter)" || die "Unable to retrieve release metadata and no cache available."
            printf 'Using cached CodeIgniter appstarter %s (offline)\n' "${release_tag}"
        fi
    else
        release_tag="${version}"
        tarball_url="https://api.github.com/repos/codeigniter4/appstarter/tarball/${release_tag}"
    fi

    cache_file="${APPSTARTER_CACHE_DIR}/appstarter-${release_tag}.tar.gz"

    if [[ ${force_download} -eq 1 ]]; then
        rm -f "${cache_file}"
    fi

    if [[ -f "${cache_file}" ]]; then
        printf 'Using cached CodeIgniter appstarter %s\n' "${release_tag}"
    else
        if [[ -z "${tarball_url}" ]]; then
            die "Archive ${cache_file##*/} not found and cannot download (offline)."
        fi
        printf 'Downloading CodeIgniter appstarter %s...\n' "${release_tag}"
        download_tarball "${tarball_url}" "${cache_file}"
    fi

    local tmpdir
    tmpdir="$(mktemp -d)"
    trap 'if [[ -n "${tmpdir:-}" ]]; then rm -rf "${tmpdir}"; fi' EXIT

    if ! tar -xz -f "${cache_file}" -C "${tmpdir}" --strip-components=1; then
        rm -rf "${tmpdir}"
        trap - EXIT
        die "Failed to extract cached archive ${cache_file}"
    fi

    ensure_app_root_writable

    local paths=(
        app
        public
        writable
        tests
        spark
        composer.json
        composer.lock
        env
        phpunit.xml.dist
        .gitignore
    )

    for item in "${paths[@]}"; do
        if [[ -e "${tmpdir}/${item}" ]]; then
            copy_path "${tmpdir}/${item}" "${APP_ROOT}/${item}"
        fi
    done

    if [[ ! -f "${APP_ROOT}/.env" && -f "${APP_ROOT}/env" ]]; then
        cp "${APP_ROOT}/env" "${APP_ROOT}/.env"
    fi

    apply_env_defaults

    find "${APP_ROOT}/writable" -type d -exec chmod 775 {} \; 2>/dev/null || true
    find "${APP_ROOT}/writable" -type f -exec chmod 664 {} \; 2>/dev/null || true

    rm -rf "${tmpdir}"
    trap - EXIT

    if [[ ${skip_install} -ne 1 ]]; then
        printf '\nRunning composer install...\n'
        if composer_install_noninteractive; then
            printf 'Composer install completed.\n'
        else
            printf 'Composer install failed. Run "./scripts/c4ignite composer install" manually.\n'
        fi
        printf '\nInit complete. Stack is ready to run.\n'
    else
        printf '\nInit complete. Run "./scripts/c4ignite composer install" before starting.\n'
    fi
}

write_xdebug_config() {
    local mode="$1"
    local start="$2"
    mkdir -p "$(dirname "${XDEBUG_INI}")"
    cat > "${XDEBUG_INI}" <<EOF
[xdebug]
xdebug.mode=${mode}
xdebug.start_with_request=${start}
xdebug.discover_client_host=false
xdebug.client_host=${XDEBUG_DEFAULT_HOST}
xdebug.client_port=${XDEBUG_DEFAULT_PORT}
xdebug.log_level=0
EOF
}

current_xdebug_mode() {
    if [[ -f "${XDEBUG_INI}" ]]; then
        grep -E '^xdebug\.mode=' "${XDEBUG_INI}" | head -n1 | cut -d'=' -f2
    fi
}

reload_php_fpm() {
    if [[ -n "$(compose ps -q "${APP_SERVICE}" 2>/dev/null)" ]]; then
        compose_exec "${APP_SERVICE}" sh -c "kill -USR2 1" >/dev/null 2>&1 || compose_exec "${APP_SERVICE}" sh -c "kill -HUP 1" >/dev/null 2>&1 || true
        printf 'PHP-FPM reloaded with new settings.\n'
    else
        printf 'PHP container is not running; changes will apply on next start.\n'
    fi
}

cmd_xdebug() {
    local action="${1:-status}"
    case "${action}" in
        on)
            write_xdebug_config "debug,develop" "yes"
            printf 'Xdebug enabled (mode=debug,develop)\n'
            reload_php_fpm
            ;;
        off)
            write_xdebug_config "off" "no"
            printf 'Xdebug disabled\n'
            reload_php_fpm
            ;;
        status)
            local mode
            mode="$(current_xdebug_mode)"
            if [[ -z "${mode}" ]]; then
                printf 'Xdebug configuration not found at %s\n' "${XDEBUG_INI}"
            else
                printf 'Xdebug mode: %s\n' "${mode}"
            fi
            ;;
        *)
            die "Usage: c4ignite xdebug [on|off|status]"
            ;;
    esac
}

usage() {
    cat <<EOF
Usage: c4ignite <command> [options]

Commands:
  up            Start the development stack
  down          Stop the stack and remove containers
  restart       Restart running services
  status        Show service status
  pull          Pull service images from the registry
  shell         Open shell into a service 
  spark         Run 'php spark ...' inside the app container
  composer      Run Composer inside the app container
  php           Run PHP CLI inside the app container
  logs          Tail logs for the whole stack or a service
  init          Download CI4 appstarter (default: latest)
  doctor        Run environment diagnostics
  test          Execute PHPUnit via the app container
  lint          Run project linting (composer script or phpcs fallback)
  audit         Run 'composer audit'
  build         Build production image (use -t/--tag, --push)
  fresh         Clean containers/volumes (--reinit to rebuild src/)
  migrate       Run php spark migrate
  backup        Manage src/ backups (create/list/restore/info)
  setup shell   Wizard to install/remove aliases & auto-complete
  setup env     Manage .env templates (list/copy)
  xdebug cmd    Manage xdebug (on|off|status)
EOF
}

main() {
    local cmd="${1:-}"
    shift || true

    case "${cmd}" in
        up) cmd_up "$@" ;;
        down) cmd_down "$@" ;;
        restart) cmd_restart "$@" ;;
        status) cmd_status "$@" ;;
        pull) cmd_pull "$@" ;;
        shell) cmd_shell "$@" ;;
        spark) cmd_spark "$@" ;;
        composer) cmd_composer "$@" ;;
        php) cmd_php "$@" ;;
        logs) cmd_logs "$@" ;;
        init) cmd_init "$@" ;;
        doctor) cmd_doctor "$@" ;;
        test) cmd_test "$@" ;;
        lint) cmd_lint "$@" ;;
        audit) cmd_audit "$@" ;;
        build) cmd_build "$@" ;;
        fresh) cmd_fresh "$@" ;;
        migrate) cmd_migrate "$@" ;;
        backup) cmd_backup "$@" ;;
        setup) cmd_setup "$@" ;;
        xdebug) cmd_xdebug "$@" ;;
        ""|-h|--help) usage ;;
        *) usage; die "unknown command: ${cmd}" ;;
    esac
}

main "$@"
